<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VOID_SNAKE Horror</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;800&display=swap');

        body {
            background-color: black;
            font-family: 'JetBrains+Mono', monospace;
            overflow: hidden;
            color: #22c55e;
        }

        .scanline {
            background: linear-gradient(to bottom, rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.2) 50%);
            background-size: 100% 4px;
            pointer-events: none;
            position: absolute;
            inset: 0;
            z-index: 10;
        }

        .vhs-text {
            text-shadow: 2px 0 #f00, -2px 0 #0ff;
            animation: jitter 0.2s infinite;
        }

        @keyframes jitter {
            0% { transform: translate(0,0); }
            50% { transform: translate(-1px, 1px); }
        }

        canvas {
            image-rendering: pixelated;
        }

        .hidden-ui { display: none !important; }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-4 touch-none">

    <!-- AI Messages Overlay -->
    <div id="ai-overlay" class="fixed top-20 w-full text-center z-[100] pointer-events-none animate-pulse hidden-ui">
        <p id="ai-text" class="text-2xl font-black uppercase tracking-widest vhs-text">✨ WHISPERING...</p>
    </div>

    <!-- 3D Void Overlay -->
    <canvas id="three-canvas" class="fixed inset-0 z-50 bg-black hidden-ui"></canvas>

    <!-- Post-Mortem Overlay -->
    <div id="burn-overlay" class="fixed inset-0 z-[60] bg-black flex flex-col items-center justify-center p-10 text-center hidden-ui">
        <div id="activity-icon" class="mb-4 text-red-600">
            <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="animate-bounce"><path d="M22 12h-4l-3 9L9 3l-3 9H2"/></svg>
        </div>
        <p id="fate-text" class="text-red-500 text-2xl font-bold vhs-text uppercase max-w-2xl">✨ PROCESSING SOUL DATA...</p>
    </div>

    <!-- Main Game Container -->
    <div class="relative border-4 border-green-900/30 shadow-[0_0_50px_rgba(0,50,0,0.3)]">
        <div class="scanline"></div>
        <canvas id="game-canvas" width="400" height="400"></canvas>

        <!-- UI Overlay -->
        <div id="start-screen" class="absolute inset-0 bg-black/95 z-20 flex flex-col items-center justify-center p-8 text-center">
            <div class="text-green-900 mb-4 opacity-50">
                <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9.5 2A2.5 2.5 0 0 1 12 4.5v15a2.5 2.5 0 0 1-4.96.44 2.5 2.5 0 0 1-2.96-3.08 3 3 0 0 1-.34-5.58 2.5 2.5 0 0 1 1.32-4.24 2.5 2.5 0 0 1 4.44-2.54Z"/><path d="M14.5 2A2.5 2.5 0 0 0 12 4.5v15a2.5 2.5 0 0 0 4.96.44 2.5 2.5 0 0 0 2.96-3.08 3 3 0 0 0 .34-5.58 2.5 2.5 0 0 0-1.32-4.24 2.5 2.5 0 0 0-4.44-2.54Z"/></svg>
            </div>
            <div id="prognosis" class="mb-6 text-[10px] text-green-700 uppercase tracking-widest animate-pulse">
                ✨ PROGNOSIS: AWAITING VITALS...
            </div>
            <h1 id="status-title" class="text-6xl font-black text-green-600 tracking-tighter vhs-text mb-8">HEART_SYNC</h1>
            <button id="start-btn" class="bg-green-900/20 border border-green-500 text-green-500 px-10 py-4 font-black uppercase hover:bg-green-500 hover:text-black transition-all shadow-lg">
                ✨ INITIATE
            </button>
        </div>
    </div>

    <!-- Controls -->
    <div class="mt-8 grid grid-cols-3 gap-4">
        <div id="timestamp" class="absolute bottom-4 left-4 text-[8px] opacity-20 uppercase tracking-widest">MAR. 24 1994</div>
        <div id="score-display" class="absolute bottom-4 right-4 text-[10px] opacity-40 uppercase">BEATS: 0</div>

        <div></div>
        <button id="up-btn" class="p-4 border border-green-900/30 text-green-900 active:text-green-400">
            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m18 15-6-6-6 6"/></svg>
        </button>
        <div></div>
        <button id="left-btn" class="p-4 border border-green-900/30 text-green-900 active:text-green-400">
            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 18-6-6 6-6"/></svg>
        </button>
        <button id="down-btn" class="p-4 border border-green-900/30 text-green-900 active:text-green-400">
            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m6 9 6 6 6-6"/></svg>
        </button>
        <button id="right-btn" class="p-4 border border-green-900/30 text-green-900 active:text-green-400">
            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m9 18 6-6-6-6"/></svg>
        </button>
    </div>

    <script>
        // --- CONSTANTS & STATE ---
        const CANVAS_SIZE = 400;
        const GRID_SIZE = 20;
        const INITIAL_SNAKE = [{ x: 10, y: 10 }, { x: 10, y: 11 }, { x: 10, y: 12 }];
        const apiKey = ""; // Provided by environment

        let snake = [...INITIAL_SNAKE];
        let food = { x: 5, y: 5 };
        let direction = { x: 0, y: -1 };
        let nextDirection = { x: 0, y: -1 };
        let score = 0;
        let gameStarted = false;
        let gameOver = false;
        let cutscene = false;
        let audioCtx = null;

        const gCanvas = document.getElementById('game-canvas');
        const gCtx = gCanvas.getContext('2d');

        // --- GEMINI API ---
        async function callGemini(prompt, systemPrompt) {
            let delay = 1000;
            for (let i = 0; i < 5; i++) {
                try {
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: prompt }] }],
                            systemInstruction: { parts: [{ text: systemPrompt }] }
                        })
                    });
                    if (!response.ok) throw new Error('API Error');
                    const result = await response.json();
                    return result.candidates?.[0]?.content?.parts?.[0]?.text;
                } catch (err) {
                    if (i === 4) return null;
                    await new Promise(r => setTimeout(r, delay));
                    delay *= 2;
                }
            }
        }

        async function generatePrognosis() {
            const el = document.getElementById('prognosis');
            el.innerText = "✨ PROGNOSIS: CALCULATING FATE...";
            const res = await callGemini(
                "The boy is connected to the EKG. Predict his chances of survival in one short, bleak sentence.",
                "You are a cold, terminal hospital AI. You provide zero hope."
            );
            if (res) el.innerText = "✨ PROGNOSIS: " + res;
        }

        async function generateHallucination() {
            const overlay = document.getElementById('ai-overlay');
            const text = document.getElementById('ai-text');
            const res = await callGemini(
                `The patient's heart rate is climbing. Current score: ${score}. What does the void whisper to him?`,
                "You are a malevolent entity inhabiting a 1994 medical monitor. Responses must be under 10 words and terrifying."
            );
            if (res) {
                text.innerText = "✨ " + res;
                overlay.classList.remove('hidden-ui');
                setTimeout(() => overlay.classList.add('hidden-ui'), 5000);
            }
        }

        async function generatePostMortem() {
            const text = document.getElementById('fate-text');
            const res = await callGemini(
                `Subject flatlined after ${score} heartbeats. Provide a clinical autopsy summary of his digital soul.`,
                "You are a 1990s diagnostic terminal. Your output is grainy, cold, and haunting. Max 20 words."
            );
            text.innerText = "✨ " + (res || "SYSTEM FAILURE. SOUL NOT FOUND.");
        }

        // --- AUDIO ---
        function playSound(freq, type, duration) {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') audioCtx.resume();

            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }

        // --- THREE.JS VOID ---
        let threeScene, threeCamera, threeRenderer, frameId, clock;
        let monitorGlow, patientHead, flatlineLight;

        function initThree() {
            const canvas = document.getElementById('three-canvas');
            clock = new THREE.Clock();
            threeScene = new THREE.Scene();
            threeScene.background = new THREE.Color(0x010101);
            threeScene.fog = new THREE.FogExp2(0x010101, 0.02);

            threeCamera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
            threeCamera.position.set(20, 15, 45);

            threeRenderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            threeRenderer.setSize(window.innerWidth, window.innerHeight);

            const floor = new THREE.Mesh(new THREE.PlaneGeometry(500, 500), new THREE.MeshStandardMaterial({ color: 0x050505 }));
            floor.rotation.x = -Math.PI / 2;
            threeScene.add(floor);

            const mattress = new THREE.Mesh(new THREE.BoxGeometry(15, 3, 30), new THREE.MeshStandardMaterial({ color: 0xaaaaaa }));
            mattress.position.y = 4;
            threeScene.add(mattress);

            patientHead = new THREE.Mesh(new THREE.SphereGeometry(1.8, 16, 16), new THREE.MeshStandardMaterial({ color: 0x888888 }));
            patientHead.position.set(0, 6, -10);
            threeScene.add(patientHead);

            const body = new THREE.Mesh(new THREE.CylinderGeometry(2.5, 2.5, 12, 12), new THREE.MeshStandardMaterial({ color: 0x333344 }));
            body.rotation.x = Math.PI / 2;
            body.position.set(0, 5, 2);
            threeScene.add(body);

            monitorGlow = new THREE.PointLight(0x00ff00, 2, 15);
            monitorGlow.position.set(-12, 10, -7);
            threeScene.add(monitorGlow);

            flatlineLight = new THREE.RectAreaLight(0xff0000, 0, 100, 100);
            flatlineLight.position.set(0, 20, 0);
            threeScene.add(flatlineLight);

            threeScene.add(new THREE.AmbientLight(0x111111));
            animateThree();
        }

        function animateThree() {
            frameId = requestAnimationFrame(animateThree);
            const t = clock.getElapsedTime();

            if (t < 5) {
                const beat = Math.pow(Math.sin(t * 1.5 * Math.PI), 10);
                monitorGlow.intensity = beat * 4;
                patientHead.position.y = 6 + beat * 0.1;
            } else {
                monitorGlow.color.set(0xff0000);
                monitorGlow.intensity = 1;
                patientHead.position.y = 5.8;
                flatlineLight.intensity = Math.min(10, (t - 5) * 2);
            }

            threeCamera.position.x = 20 + Math.sin(t * 0.2) * 5;
            threeCamera.lookAt(0, 5, 0);
            threeRenderer.render(threeScene, threeCamera);
        }

        // --- GAME LOGIC ---
        function moveSnake() {
            if (!gameStarted || gameOver || cutscene) return;

            const head = { ...snake[0] };
            head.x += nextDirection.x;
            head.y += nextDirection.y;

            if (head.x < 0 || head.x >= 20 || head.y < 0 || head.y >= 20 ||
                snake.some(s => s.x === head.x && s.y === head.y)) {
                triggerDeath();
                return;
            }

            snake.unshift(head);
            if (head.x === food.x && head.y === food.y) {
                score++;
                document.getElementById('score-display').innerText = `BEATS: ${score}`;
                food = { x: Math.floor(Math.random() * 20), y: Math.floor(Math.random() * 20) };
                playSound(600, 'sine', 0.1);
                if (Math.random() > 0.7) generateHallucination();
            } else {
                snake.pop();
            }
            direction = nextDirection;
        }

        function triggerDeath() {
            cutscene = true;
            playSound(100, 'sawtooth', 0.5);
            generatePostMortem();

            setTimeout(() => {
                document.getElementById('three-canvas').classList.remove('hidden-ui');
                initThree();
            }, 1000);

            setTimeout(() => {
                document.getElementById('burn-overlay').classList.remove('hidden-ui');
            }, 9000);

            setTimeout(() => {
                cancelAnimationFrame(frameId);
                document.getElementById('three-canvas').classList.add('hidden-ui');
                document.getElementById('burn-overlay').classList.add('hidden-ui');
                document.getElementById('start-screen').classList.remove('hidden-ui');
                document.getElementById('status-title').innerText = "FLATLINED";
                document.getElementById('start-btn').innerText = "✨ REANIMATE";
                gameOver = true;
                gameStarted = false;
                cutscene = false;
                generatePrognosis();
            }, 14000);
        }

        function draw() {
            gCtx.fillStyle = '#010501';
            gCtx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            gCtx.strokeStyle = '#002200';
            for(let i=0; i<CANVAS_SIZE; i+=GRID_SIZE) {
                gCtx.beginPath(); gCtx.moveTo(i, 0); gCtx.lineTo(i, CANVAS_SIZE); gCtx.stroke();
                gCtx.beginPath(); gCtx.moveTo(0, i); gCtx.lineTo(CANVAS_SIZE, i); gCtx.stroke();
            }

            if (gameStarted) {
                gCtx.fillStyle = '#00ff00';
                gCtx.fillRect(food.x * GRID_SIZE + 5, food.y * GRID_SIZE + 5, 10, 10);
                gCtx.strokeStyle = '#00ff00';
                gCtx.lineWidth = 3;
                gCtx.beginPath();
                snake.forEach((s, i) => {
                    const x = s.x * GRID_SIZE + GRID_SIZE/2;
                    const y = s.y * GRID_SIZE + GRID_SIZE/2;
                    if(i === 0) gCtx.moveTo(x, y); else gCtx.lineTo(x, y);
                });
                gCtx.stroke();
            }
            requestAnimationFrame(draw);
        }

        // --- EVENT HANDLERS ---
        function updateDir(newDir) {
            if (newDir.x === -direction.x && newDir.y === -direction.y) return;
            nextDirection = newDir;
        }

        document.getElementById('start-btn').onclick = () => {
            snake = [...INITIAL_SNAKE];
            direction = { x: 0, y: -1 };
            nextDirection = { x: 0, y: -1 };
            score = 0;
            document.getElementById('score-display').innerText = "BEATS: 0";
            document.getElementById('start-screen').classList.add('hidden-ui');
            gameStarted = true;
            gameOver = false;
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            audioCtx.resume();
        };

        window.onkeydown = (e) => {
            switch(e.key) {
                case 'ArrowUp': updateDir({x:0, y:-1}); break;
                case 'ArrowDown': updateDir({x:0, y:1}); break;
                case 'ArrowLeft': updateDir({x:-1, y:0}); break;
                case 'ArrowRight': updateDir({x:1, y:0}); break;
            }
        };

        document.getElementById('up-btn').onpointerdown = () => updateDir({x:0, y:-1});
        document.getElementById('down-btn').onpointerdown = () => updateDir({x:0, y:1});
        document.getElementById('left-btn').onpointerdown = () => updateDir({x:-1, y:0});
        document.getElementById('right-btn').onpointerdown = () => updateDir({x:1, y:0});

        // Loop
        setInterval(moveSnake, 130);
        draw();
        generatePrognosis();

        // Timer
        setInterval(() => {
            document.getElementById('timestamp').innerText = `MAR. 24 1994 ${new Date().toLocaleTimeString([], { hour12: false })}`;
        }, 1000);
    </script>
</body>
</html>